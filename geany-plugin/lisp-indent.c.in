#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <geanyplugin.h>


#define SCE_LISP_OPERATOR 10

#define GLISP_TOOLS_BASE "@INSTALL_DIR@"

GeanyPlugin     *geany_plugin;
GeanyData       *geany_data;
GeanyFunctions  *geany_functions;

PLUGIN_VERSION_CHECK(211)
PLUGIN_SET_INFO("Lisp Indenting", "Lisp Indentation",
                "1.0", "John Doe <john.doe@example.org>");
PLUGIN_KEY_GROUP(lisp, 1);
//static GtkWidget *main_menu_item = NULL;

static void kb_run_lisp_complete(G_GNUC_UNUSED guint key_id);

static gboolean notify_cb(GObject *obj, GeanyEditor *ed, SCNotification *nt, gpointer user_data);
PluginCallback plugin_callbacks[] =
{
    {"editor_notify", (GCallback)&notify_cb, TRUE,NULL},
    {NULL,NULL,FALSE,NULL}
};


static int charAdded;
static long charAddedAt;

static gint get_indent_for_line(ScintillaObject *sci, gint start, gint end);
static gint get_whitespace_start(gchar *line);

static gint get_paren_indent(ScintillaObject *sci, gint line)
{
    return get_indent_for_line(sci, 0, line+1);
}

static gint setup_pipe(const char *program, int *pipefd, FILE **outf, int *outpid) 
{
    int pipefds[2] = {0};
    int pid;

    FILE *outfile = tmpfile();

    if(outfile == NULL) {
        goto error0;
    }

    if(pipe(pipefds)) {
        goto error1;
    }

    pid = fork();

    if ( pid < 0) {
        goto error2;
    }

    if( pid == 0 ) {
        dup2(pipefds[0], 0);
        close(pipefds[1]);
        dup2(fileno(outfile),1);
        execl(program,"",NULL);
    }

    close(pipefds[0]);
    *outf = outfile;
    *pipefd=pipefds[1];
    *outpid=pid;

    return 0;

error2:
    close(pipefds[0]);
    close(pipefds[1]);

error1:
    fclose(outfile);
error0:
    return -1;
}

static gint get_indent_for_line(ScintillaObject *sci, gint start, gint end)
{
    int pipefd;
    int pid;
    gint i;
    size_t n = 0;

    FILE *outfile=NULL;
    gchar *line_buf = NULL;

    if(setup_pipe(GLISP_TOOLS_BASE "lispindent", &pipefd, &outfile, &pid)) {
        fprintf(stderr,"Unable to run lispindent\n");
        return 0;
    }


    for(i=start;i<end;++i)
    {
        line_buf = sci_get_line(sci, i);
        if(line_buf == NULL) {
            goto error;
        }
        write(pipefd, line_buf, strlen(line_buf));
        g_free(line_buf);
        line_buf = NULL;
    }
    write(pipefd,"X\n", 2);

    close(pipefd);
    //TODO check for success
    waitpid(pid,NULL,0);

    fflush(outfile);
    fseek(outfile,0,SEEK_SET);

    for(i=start;i<end-1;++i) {
        getline(&line_buf, &n, outfile);
        fprintf(stderr,"LINE: %s\n",line_buf);
        free(line_buf);
        line_buf = NULL;
        n=0;
    }

    {
        gint prev_indent;
        gint new_indent;

        getline(&line_buf, &n, outfile);
        fprintf(stderr,"LINE: %s\n",line_buf);
        prev_indent = get_whitespace_start(line_buf);

        free(line_buf);
        line_buf = NULL;
        n=0;

        getline(&line_buf, &n, outfile);
        new_indent = get_whitespace_start(line_buf);

        free(line_buf);
        line_buf = NULL;
        n=0;

        return scintilla_send_message(sci, SCI_GETLINEINDENTATION,end-1,0) + (new_indent - prev_indent);
    }

error:
    if(line_buf != NULL) {
        g_free(line_buf);
    }
    close(pipefd);
    fclose(outfile);
    return 0;
}

static gint get_whitespace_start(gchar *line)
{
    gint position = 0;
    int i;

    for (i=0;line[i];++i) {
        switch (line[i]) {
            case ' ':
                position++;
                break;
            case '\t':
                //TODO figure out actual tab-stop
                position +=8;
                break;
            default:
                return position;
        }
    }
    return position;
}


static void charadded_cb(GeanyEditor *ed, SCNotification *nt)
{
    //dialogs_show_msgbox(GTK_MESSAGE_INFO, "Char: %d",nt->ch);
    static char spaces[4096*2];
    if (spaces[0]==0) {
        memset(spaces,' ',sizeof(spaces));
    }
    switch(nt->ch) {
        case '\n':
            charAdded=1; 
            charAddedAt=scintilla_send_message(ed->sci,SCI_GETCURRENTPOS,0,0);
            {
                long level;
                int line;
                int position;

                charAdded=0;
                //dialogs_show_msgbox(GTK_MESSAGE_INFO, "Line No: %ld",cur_lineno(ed->sci));
                //position=scintilla_send_message(ed->sci,SCI_POSITIONAFTER,charAddedAt,0);
                position=charAddedAt;
                //before=scintilla_send_message(ed->sci,SCI_POSITIONBEFORE,position,0);
                line=scintilla_send_message(ed->sci,SCI_LINEFROMPOSITION,
                        position,0);
                //level=scintilla_send_message(ed->sci,SCI_GETLINEINDENTATION,
                //line-1,0);
                //level &= SC_FOLDLEVELNUMBERMASK;
                //level -= 1024;
                level = get_paren_indent(ed->sci,line-1);
                //fprintf(stderr,"Indent: %d\n",moreindent);
                fprintf(stderr,"Level: %ld\n",level);
                scintilla_send_message(ed->sci,SCI_SETLINEINDENTATION,line,level);
                scintilla_send_message(ed->sci,SCI_GOTOPOS,
                        scintilla_send_message(ed->sci,SCI_GETLINEINDENTPOSITION,line,0),0);
                //spaces[2*level]=0;
                //scintilla_send_message(ed->sci,SCI_INSERTTEXT,position,(long)spaces);
                //spaces[2*level]=' ';
                /*
                   line=scintilla_send_message(ed->sci,SCI_LINEFROMPOSITION,
                   position,0);
                   level=scintilla_send_message(ed->sci,SCI_GETFOLDLEVEL,
                   line,0);
                   level &= SC_FOLDLEVELNUMBERMASK;
                   level -= 1024;
                   fprintf(stderr,"Level2: %ld\n",level);
                   */

            }
            break;
    }
}


static gboolean notify_cb(G_GNUC_UNUSED GObject *obj, GeanyEditor *ed, SCNotification *nt, G_GNUC_UNUSED gpointer user_data)
{
    if(!ed->document ||
            ed->document->file_type->id != GEANY_FILETYPES_LISP) {
        return FALSE;
    }
    //fprintf(stderr,"Code: %d\n",nt->nmhdr.code);
    switch(nt->nmhdr.code) {
        case SCN_CHARADDED:
            charadded_cb(ed,nt);
            break;
    }
    return FALSE;
}

void plugin_init(G_GNUC_UNUSED GeanyData *data)
{
    keybindings_set_item(plugin_key_group, 0, kb_run_lisp_complete,
            0, 0, "run_lisp_complete", "Complete lisp symbol", NULL);
}
void plugin_cleanup(void)
{
    //gtk_widget_destroy(main_menu_item);
}

static gchar *read_to_end_of_file(FILE *f)
{
    long start = ftell(f);
    long end;
    gchar *buf=NULL;

    fseek(f, 0L, SEEK_END);

    end = ftell(f);

    fseek(f, start, SEEK_SET);

    buf = g_malloc0(1+end-start);

    if(buf != NULL) {
        size_t bytes_read = fread(buf,1,end-start,f);
        if(bytes_read != (unsigned long)end-start) {
            g_free(buf);
            return NULL;
        }
    }

    return buf;
}

static void get_completions(ScintillaObject *sci, long *backtrack, gchar **partial, gchar**completions) 
{
    int pipefd;
    int pid;
    size_t n = 0;

    FILE *outfile=NULL;
    gchar *line_buf = NULL;

    gint pos = sci_get_current_position(sci);

    *completions=NULL;
    *backtrack=0;
    *partial=NULL;

    if(setup_pipe(GLISP_TOOLS_BASE "lispcomplete", &pipefd, &outfile, &pid)) {
        fprintf(stderr,"Unable to run lispcomplete\n");
        return;
    }

    //Todo if pos is large, chunk this
    line_buf = sci_get_contents_range(sci,0,pos);

    if(line_buf == NULL) {
        goto error;
    }

    write(pipefd,line_buf,strlen(line_buf));

    g_free(line_buf);
    line_buf = NULL;

    close(pipefd);
    //TODO check for success
    waitpid(pid,NULL,0);

    fflush(outfile);
    fseek(outfile,0,SEEK_SET);

    getline(&line_buf, &n, outfile);
    if(line_buf == NULL) {
        goto error;
    }
    
    *backtrack = strtol(line_buf,NULL,10);
    g_free(line_buf);
    line_buf=NULL;

    getline(&line_buf, &n, outfile);
    if(line_buf == NULL) {
        goto error;
    }

    *partial=line_buf;
    line_buf=NULL;

    *completions = read_to_end_of_file(outfile);

error:
    if(line_buf != NULL) {
        g_free(line_buf);
    }
    close(pipefd);
    fclose(outfile);
    return;
}

static void kb_run_lisp_complete(G_GNUC_UNUSED guint key_id)
{
    GeanyDocument* doc = document_get_current();
    GeanyEditor* editor;
    ScintillaObject *sci;
    long rootlen;
    gchar *partial;
    gchar *completions;

    if(!doc || !doc->editor || ! doc->editor->sci) {
        return;
    }
    editor = doc->editor;
    sci = editor->sci;

    get_completions(sci, &rootlen, &partial, &completions);

    if (completions == NULL) goto error;

    // TODO do this only once per editor
    scintilla_send_message(sci,SCI_AUTOCSETORDER,SC_ORDER_CUSTOM,0);
    scintilla_send_message(sci,SCI_AUTOCSETSEPARATOR,'\n',0);

    scintilla_send_message(sci,SCI_AUTOCSHOW,rootlen,(intptr_t)completions);

error:
    if(completions != NULL) g_free(completions);
    if(partial != NULL) g_free(partial);
}

